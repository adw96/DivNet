% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{get_Y_new_and_sigSum}
\alias{get_Y_new_and_sigSum}
\title{get_Y_new_and_sigSum}
\usage{
get_Y_new_and_sigSum(num_samples, Y, W, eY, base, sigInv, mciters,
  iters_to_burn, stepsize)
}
\arguments{
\item{num_samples}{Number of samples (nrow(Y))}

\item{Y}{Logratio matrix}

\item{W}{Corresponding count matrix}

\item{eY}{Current expected value of logratio matrix}

\item{base}{OTU index used for base (1-based index)}

\item{sigInv}{Output of *_network(sigma)}

\item{mciters}{Number of MC iterations}

\item{iters_to_burn}{How many MC iters to burn?}

\item{stepsize}{Variance used for MH samples.
Tweak to adjust acceptance ratio.}
}
\value{
Returns a List containing Y_new and sigSum.
}
\description{
Calculate Y_new and sigSum for the current EM iteration.
}
\details{
This function avoids having to keep a 3D array in memory and do
matrix math along weird strides by updating sigSum after each
non-burnt MC iteration, and by keeping a running total of estimated
Y values after each non-burnt MC iteration for each sample
(converted to a mean at the end of MC iterations).  This also gives
the benefit of saving a lot of memory vs. the straight R versions
which needed to apply and reduce across a couple different
dimensions.  In theory, this should also allow more optimal storage
for faster calculations and less memory churn, with the downside
being a more complicated function.
}
\author{
Ryan Moore
}
